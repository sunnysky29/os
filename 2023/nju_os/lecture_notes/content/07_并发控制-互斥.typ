#import "../template.typ": *
#pagebreak()
= å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥

== äº’æ–¥é—®é¢˜ï¼šå®šä¹‰ä¸å‡è®¾

#tip("Tip")[
å¦‚æœæ‰“ç ´è¯»å†™åŸå­æ€§çš„å‡è®¾ï¼Œé‚£petersonçš„ç®—æ³•æ˜¯é”™è¯¯çš„ã€‚
]

=== å›é¡¾ï¼šå¹¶å‘ç¼–ç¨‹

ç†è§£å¹¶å‘çš„å·¥å…·

- çº¿ç¨‹ = äºº (å¤§è„‘èƒ½å®Œæˆå±€éƒ¨å­˜å‚¨å’Œè®¡ç®—)
- å…±äº«å†…å­˜ = ç‰©ç†ä¸–ç•Œ (ç‰©ç†ä¸–ç•Œå¤©ç”Ÿå¹¶è¡Œ)
- ä¸€åˆ‡éƒ½æ˜¯çŠ¶æ€æœº (debugger & model checker)

#tip("Tip")[
â€œèº²è¿›å•æ‰€é”ä¸Šé—¨ï¼Œæˆ‘å°±æŠŠå…¨ä¸–ç•Œäººé”åœ¨äº†å•æ‰€å¤–â€
]

=== äº’æ–¥é—®é¢˜ï¼šå®šä¹‰

äº’æ–¥ (mutual exclusion)ï¼Œâ€œäº’ç›¸æ’æ–¥â€

å®ç° lock_t æ•°æ®ç»“æ„å’Œ lock/unlock API:

```c
typedef struct {
  ...
} lock_t;
void lock(lock_t *lk);
void unlock(lock_t *lk);
```

ä¸€æŠŠ â€œæ’ä»–æ€§â€ çš„é”â€”â€”å¯¹äºé”å¯¹è±¡ lk

- å¦‚æœæŸä¸ªçº¿ç¨‹æŒæœ‰é”ï¼Œåˆ™å…¶ä»–çº¿ç¨‹çš„ lock ä¸èƒ½è¿”å› (Safety)
- åœ¨å¤šä¸ªçº¿ç¨‹æ‰§è¡Œ lock æ—¶ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªå¯ä»¥è¿”å› (Liveness)
- èƒ½*æ­£ç¡®å¤„ç†å¤„ç†å™¨ä¹±åºã€å®½æ¾å†…å­˜æ¨¡å‹å’Œç¼–è¯‘ä¼˜åŒ–*

=== äº’æ–¥é—®é¢˜çš„ç»å…¸ç®—æ³•

Peterson ç®—æ³•

- åŒ…é—´ã€æ——å­å’Œé—¨ä¸Šçš„å­—æ¡
- å‡è®¾ atomic load/store
  - å®ç°è¿™ä¸ªå‡è®¾ä¹Ÿä¸æ˜¯éå¸¸å®¹æ˜“çš„ (peterson.c)

å› æ­¤ï¼Œ*å‡è®¾å¾ˆé‡è¦*

- ä¸èƒ½åŒæ—¶è¯»/å†™å…±äº«å†…å­˜ (1960s) ä¸æ˜¯ä¸€ä¸ªå¥½çš„å‡è®¾
  - Load (ç¯é¡¾å››å‘¨) çš„æ—¶å€™ä¸èƒ½å†™ï¼Œâ€œçœ‹ä¸€çœ¼å°±æŠŠçœ¼ç›é—­ä¸Šâ€
  - Store (æ”¹å˜ç‰©ç†ä¸–ç•ŒçŠ¶æ€) çš„æ—¶å€™ä¸èƒ½è¯»ï¼Œâ€œé—­ç€çœ¼ç›åŠ¨æ‰‹â€
  - è¿™æ˜¯ã€Šæ“ä½œç³»ç»Ÿã€‹è¯¾
  - æ›´å–œæ¬¢*ç›´è§‚ã€ç®€å•ã€ç²—æš´ (ç¨³å®š)ã€æœ‰æ•ˆ*çš„è§£å†³æ–¹æ³•

=== å®ç°äº’æ–¥çš„åŸºæœ¬å‡è®¾

å…è®¸ä½¿ç”¨ä½¿æˆ‘ä»¬å¯ä»¥ä¸ç®¡ä¸€åˆ‡éº»çƒ¦äº‹çš„åŸå­æŒ‡ä»¤

```c
void atomic_inc(long *ptr);
int atomic_xchg(int val, int *ptr);
```

çœ‹èµ·æ¥æ˜¯ä¸€ä¸ªæ™®é€šçš„å‡½æ•°ï¼Œä½†å‡è®¾ï¼š

- åŒ…å«ä¸€ä¸ªåŸå­æŒ‡ä»¤
  - æŒ‡ä»¤çš„æ‰§è¡Œä¸èƒ½è¢«æ‰“æ–­
- åŒ…å«ä¸€ä¸ª compiler barrier
  - æ— è®ºä½•ç§ä¼˜åŒ–éƒ½ä¸å¯è¶Šè¿‡æ­¤å‡½æ•°
- åŒ…å«ä¸€ä¸ª memory fence
  - ä¿è¯å¤„ç†å™¨åœ¨ stop-the-world å‰æ‰€æœ‰å¯¹å†…å­˜çš„ store éƒ½ â€œç”Ÿæ•ˆâ€ >
    ä¾‹å¦‚ï¼ŒåŸå­æŒ‡ä»¤å‰æœ‰ä¸ªsum++ï¼Œé‚£è¿™ä¸ªsum++çš„å€¼å¿…é¡»åœ¨åŸå­æŒ‡ä»¤æ‰§è¡Œå‰å†™å›åˆ°å†…å­˜é‡Œã€‚
  - å³å¯¹ resume-the-world ä¹‹åçš„ load å¯è§

=== Atomic Exchange å®ç°

```c
int xchg(int volatile *ptr, int newval) {
  int result;
  asm volatile(
    // æŒ‡ä»¤è‡ªå¸¦ memory barrier
    "lock xchgl %0, %1"
    : "+m"(*ptr), "=a"(result)  // Output
    : "1"(newval)   // Input
    // Compiler barrier
    : "memory" // clobber
  );
  return result;
}
```

== è‡ªæ—‹é” (Spin Lock)

=== å®ç°äº’æ–¥ï¼šåšé¢˜å®¶ v.s. ç§‘å­¦å®¶

```c
void lock(lock_t *lk);
void unlock(lock_t *lk);
```

åšé¢˜å®¶ï¼šæ‹¿åˆ°é¢˜å°±å¼€å§‹æ’åˆ—ç»„åˆ

- ç†Ÿç»ƒå¾—è®©äººå¿ƒç–¼
- å¦‚æœé•¿ä¹…çš„è®­ç»ƒéƒ½æ˜¯
  â€œå¿…é¡»åœ¨è§„å®šçš„æ—¶é—´å†…æ­£ç¡®è§£å‡ºé—®é¢˜â€ï¼Œé‚£ä¹ˆæµªè´¹æ—¶é—´çš„æ€è€ƒè‡ªç„¶å°±å°‘äº†

ç§‘å­¦å®¶ï¼šè€ƒè™‘æ›´å¤šæ›´æ ¹æœ¬çš„é—®é¢˜

- æˆ‘ä»¬å¯ä»¥è®¾è®¡å‡ºæ€æ ·çš„åŸå­æŒ‡ä»¤ï¼Ÿ
  - å®ƒä»¬çš„è¡¨è¾¾èƒ½åŠ›å¦‚ä½•ï¼Ÿ
- è®¡ç®—æœºç¡¬ä»¶å¯ä»¥æä¾›æ¯” â€œä¸€æ¬¡ load/storeâ€ æ›´å¼ºçš„åŸå­æ€§å—ï¼Ÿ -
  å¦‚æœç¡¬ä»¶å¾ˆå›°éš¾ï¼Œè½¯ä»¶/ç¼–è¯‘å™¨å¯ä»¥ä¹ˆï¼Ÿ

=== è‡ªæ—‹é”ï¼šç”¨ xchg å®ç°äº’æ–¥

åœ¨å•æ‰€é—¨å£æ”¾ä¸€ä¸ªæ¡Œå­ (å…±äº«å˜é‡)

- åˆå§‹æ—¶æ”¾ç€ ğŸ”‘

è‡ªæ—‹é” (Spin Lock)

- æƒ³ä¸Šå•æ‰€çš„åŒå­¦ (ä¸€æ¡ xchg æŒ‡ä»¤)
  - Stop the world
  - çœ‹ä¸€çœ¼æ¡Œå­ä¸Šæœ‰ä»€ä¹ˆ (ğŸ”‘ æˆ– ğŸ›‘)
  - æŠŠ ğŸ›‘ æ”¾åˆ°æ¡Œä¸Š (è¦†ç›–ä¹‹å‰æœ‰çš„ä»»ä½•ä¸œè¥¿)
  - Resume the world
  - æœŸé—´çœ‹åˆ° ğŸ”‘ æ‰å¯ä»¥è¿›å•æ‰€ï¼Œå¦åˆ™é‡å¤
- å‡ºå•æ‰€çš„åŒå­¦
  - æŠŠ ğŸ”‘ æ”¾åˆ°æ¡Œä¸Š

#tip("Tip")[
æ­£ç¡®æ€§æ˜¯æ˜¾ç„¶çš„, åªæœ‰ä¸€æŠŠé”ï¼Œäº¤æ¢æ˜¯åŸå­çš„ï¼Œè°æ‹¿åˆ°å°±æ˜¯è°çš„ã€‚
]

=== å®ç°äº’æ–¥ï¼šè‡ªæ—‹é”

```c
int table = YES;

void lock() {
retry:
  int got = xchg(&table, NOPE);
  if (got == NOPE)
    goto retry;
  assert(got == YES);
}

void unlock() {
  xchg(&table, YES);  // ä¸ºä»€ä¹ˆä¸æ˜¯ table = YES; ?
}
```

(åœ¨ model checker ä¸­æ£€æŸ¥)

éå¸¸å¸¸è§çš„æ­»é”æ–¹å¼ï¼š

1. åœ¨unlockä¹‹å‰å°±è¿”å›äº†ã€‚
2. åœ¨unlockä¹‹å‰ç¨‹åºcrashäº†ã€‚ >
  C++åœ¨æ„é€ å’Œææ„çš„æ—¶å€™åˆ†åˆ«lock,unlock,å¯ä»¥ä¸€å®šç¨‹åº¦ä¸Šé¿å…é—®é¢˜ã€‚

ä¸ºä»€ä¹ˆä¸æ˜¯ `table = YES;` ? åœ¨ç¼–è¯‘ä¼˜åŒ–ï¼Œå®½æ¾å†…å­˜æ¨¡å‹ä¸‹ï¼Œéƒ½è¦æ­£ç¡®ã€‚æœ€å®‰å…¨çš„åŠæ³•ã€‚

spinlock.py

```py
def Tworker(enter, exit):
  for _ in range(2):
    while True:
      seen = heap.table
      heap.table = 'âŒ'
      sys_sched()
      if seen == 'âœ…':
        break
    sys_sched()
    sys_write(enter)
    sys_sched()
    sys_write(exit)
    sys_sched()
    heap.table = 'âœ…'
    sys_sched()

def main():
  heap.table = 'âœ…'
= "(": lock `)`:unlock
  sys_spawn(Tworker, '(', ')')
  sys_spawn(Tworker, '[', ']')

= Outputs:
= ()()[][]
= ()#link("")[][]
= ()#link("")[][]
= #link("")[]()[]
= #link("")[]#link("")[]
= #link("")[][]()
```

=== å®ç°äº’æ–¥ï¼šè‡ªæ—‹é”

åœ¨ xchg çš„å‡è®¾ä¸‹ç®€åŒ–å®ç°

- åŒ…å«ä¸€ä¸ªåŸå­æŒ‡ä»¤
- åŒ…å«ä¸€ä¸ª compiler barrier
- åŒ…å«ä¸€ä¸ª memory fence
  - sum-spinlock demo

```c
int locked = 0;

void lock() {
  while (xchg(&locked, 1));
}

void unlock() {
  xchg(&locked, 0);
}
```

sum-spinlock.c

```c
#include "thread.h"

#define N 100000000
#define M 10

long sum = 0;

int xchg(int volatile *ptr, int newval) {
  int result;
  asm volatile(
    "lock xchgl %0, %1"
    : "+m"(*ptr), "=a"(result)
    : "1"(newval)
    : "memory"
  );
  return result;
}

int locked = 0;

void lock() {
  while (xchg(&locked, 1)) ;
}

void unlock() {
  xchg(&locked, 0);
}

void Tsum() {
  long nround = N / M;
  for (int i = 0; i < nround; i++) {
    lock();
    for (int j = 0; j < M; j++) {
      sum++;  // Non-atomic; can optimize
    }
    unlock();
  }
}

int main() {
  assert(N % M == 0);
  create(Tsum);
  create(Tsum);
  join();
  printf("sum = %ld\n", sum);
}
```

O2ä¼˜åŒ–ä¸‹,ä¸­é—´çš„å¾ªç¯ç›´æ¥ï¼š`addq   $0xa,0x2e63(%rip)`

== ğŸŒ¶ï¸ ä½ ä»¬ (ä¸) æƒ³è¦çš„æ— é”ç®—æ³•

=== æ›´å¼ºå¤§çš„åŸå­æŒ‡ä»¤

Compare and exchange (â€œtest and setâ€)

- (lock) cmpxchg SRC, DEST

```py
TEMP = DEST
if accumulator == TEMP:
    ZF = 1
    DEST = SRC
else:
    ZF = 0
    accumulator = TEMP
```

- ğŸ¤” çœ‹èµ·æ¥æ²¡å¤æ‚å¤šå°‘ï¼Œå¥½åƒåˆå¤æ‚äº†å¾ˆå¤š
  - å­¦ç¼–ç¨‹/æ“ä½œç³»ç»Ÿ â€œçº¸é¢ç†è§£â€ æ˜¯ä¸è¡Œçš„
  - ä¸€å®šè¦å†™ä»£ç åŠ æ·±å°è±¡
    - å¯¹äºè¿™ä¸ªä¾‹å­ï¼šæˆ‘ä»¬å¯ä»¥åˆ—å‡º â€œçœŸå€¼è¡¨â€

å†™ä¸€ä¸ªCè¯­è¨€çš„ç¿»è¯‘ç‰ˆæœ¬.

```c
int cmpxchg(int old, int new, int volatile *ptr) {
    asm volatile("lock cmpxchgl %[new], %[mem]"
                 : "+a"(old), [mem] "+m"(*ptr)
                 : [new] "S"(new)
                 : "memory");
    return old;
}

// æœ¬è´¨è¿˜æ˜¯xchgï¼Œä½†æ˜¯å¤šäº†ä¸€ä¸ªæ¡ä»¶ï¼Œåœ¨compareç›¸ç­‰çš„æƒ…å†µä¸‹xchgã€‚æ¡ä»¶åŠ å¼ºäº†ã€‚
int cmpxchg_ref(int old, int new, int volatile *ptr) {
    int tmp = *ptr;  // Load
    if (tmp == old) {
        *ptr = new;  // Store (conditionally)
    }
    return tmp;
}

void run_test(int x, int old, int new) {
    int val1 = x;
    int ret1 = cmpxchg(old, new, &val1);

    int val2 = x;
    int ret2 = cmpxchg_ref(old, new, &val2);

    assert(val1 == val2 && ret1 == ret2);
    printf("x = %d -> (cmpxchg %d -> %d) -> x = %d\n", x, old, new, val1);
}

int main() {
    for (int x = 0; x <= 2; x++)
        for (int old = 0; old <= 2; old++)
            for (int new = 0; new <= 2; new ++) run_test(x, old, new);
}
```

==== åœ¨è‡ªæ—‹é”ä¸­ä»£æ›¿ `xchg`

åœ¨è‡ªæ—‹é”çš„å®ç°ä¸­ï¼Œ`xchg` å®Œå…¨å¯ä»¥ç”¨ `cmpxchg` ä»£æ›¿

```c
// cmpxchg(old='ğŸ”‘', new='ğŸ›‘', *ptr)
int tmp = *ptr;
if (tmp == 'ğŸ”‘') {
    *ptr = 'ğŸ›‘'
    assert(tmp == 'ğŸ”‘');
} else {
    assert(tmp == 'ğŸ›‘');
}
return tmp;
```

- è¿™ä¹ˆåšæœ‰ä»€ä¹ˆå¥½å¤„å—ï¼Ÿ
  - æœ‰çš„ï¼Œåœ¨è‡ªæ—‹å¤±è´¥çš„æ—¶å€™å‡å°‘äº†ä¸€æ¬¡ store
  - å½“ç„¶ï¼Œç°ä»£å¤„ç†å™¨ä¹Ÿå¯ä»¥ä¼˜åŒ– xchg

==== å¤šå‡ºçš„ Compare: ç”¨å¤„

åŒæ—¶æ£€æŸ¥ä¸Šä¸€æ¬¡è·å¾—çš„å€¼æ˜¯å¦ä»ç„¶æœ‰æ•ˆ + ä¿®æ”¹ç”Ÿæ•ˆ

å®ç°ä¸€ä¸ªå¹¶å‘çš„å•é“¾è¡¨.
æœ‰ä¸¤ä¸ªçº¿ç¨‹éƒ½æƒ³åœ¨headå‰æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ã€‚é‚£è¿™ä¸ªcompareå°±å¯ä»¥æ£€æŸ¥å½“å‰çš„headæ˜¯ä¸æ˜¯è‡ªå·±è®¤ä¸ºçš„é‚£ä¸ªã€‚åªæœ‰ä¸€ä¸ªèƒ½èƒœå‡ºã€‚

```c
// Create a new node
retry:
    expected = head;
    node->next = expected;
    seen = cmpxchg(expected, node, &head);
    if (seen != expected)
    goto retry;
```

é“¾è¡¨æœ€éš¾å¾—ä¸æ˜¯æ’å…¥/åˆ é™¤ï¼Œè€Œæ˜¯å›æ”¶ã€‚ ä¹ é¢˜ï¼šå¦‚ä½•å®ç° `pop()`ï¼Ÿ

ğŸŒ¶ï¸ [ Lockless Patterns: An Introduction to Compare-and-swap
](https://lwn.net/Articles/847973/) ğŸŒ¶ï¸ï¸ğŸŒ¶ï¸ [ Is Parallel Programming Hard, And, If
So, What Can You Do About It?
](https://cdn.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html)
(perfbook) ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸ [ The Art of Multiprocessor Programming
](https://www.sciencedirect.com/book/9780124159501/the-art-of-multiprocessor-programming)

== åœ¨æ“ä½œç³»ç»Ÿä¸Šå®ç°äº’æ–¥

=== è‡ªæ—‹é”çš„ç¼ºé™·

==== æ€§èƒ½é—®é¢˜ (1)

- é™¤äº†è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹ï¼Œå…¶ä»–å¤„ç†å™¨ä¸Šçš„çº¿ç¨‹éƒ½åœ¨ç©ºè½¬
- äº‰æŠ¢é”çš„å¤„ç†å™¨è¶Šå¤šï¼Œåˆ©ç”¨ç‡è¶Šä½
  - 4 ä¸ª CPU è¿è¡Œ 4 ä¸ª sum-spinlock å’Œ 1 ä¸ª OBS
    - ä»»æ„æ—¶åˆ»éƒ½åªæœ‰ä¸€ä¸ª sum-atomic åœ¨æœ‰æ•ˆè®¡ç®—
  - å‡åˆ† CPU, OBS å°±åˆ†ä¸åˆ° 100% çš„ CPU äº†

==== æ€§èƒ½é—®é¢˜ (2)

çº¿ç¨‹çš„æ•°é‡æ¯”å¤„ç†å™¨çš„æ•°é‡æ›´å¤šï¼Ÿå¯„ï¼Œæ‰€æœ‰çº¿ç¨‹éƒ½åœ¨æ‘¸é±¼ã€‚

- æŒæœ‰è‡ªæ—‹é”çš„çº¿ç¨‹å¯èƒ½è¢«æ“ä½œç³»ç»Ÿåˆ‡æ¢å‡ºå»
  - æ“ä½œç³»ç»Ÿä¸ â€œæ„ŸçŸ¥â€ çº¿ç¨‹åœ¨åšä»€ä¹ˆ
  - (ä½†ä¸ºä»€ä¹ˆä¸èƒ½å‘¢ï¼Ÿ)
- å®ç° 100% çš„èµ„æºæµªè´¹

=== Scalability: æ€§èƒ½çš„æ–°ç»´åº¦

#image("images/2024-03-18-12-42-42.png")
åŒä¸€ä»½è®¡ç®—ä»»åŠ¡ï¼Œæ—¶é—´ (CPU cycles) å’Œç©ºé—´ (mapped memory)
ä¼šéšå¤„ç†å™¨æ•°é‡çš„å¢é•¿è€Œå˜åŒ–ã€‚(æ•°é‡å¢åŠ ï¼Œæ•ˆç‡è¶Šæ¥è¶Šä½)

ç”¨è‡ªæ—‹é”å®ç° sum++ çš„æ€§èƒ½é—®é¢˜

- ä¸¥è°¨çš„ç»Ÿè®¡å¾ˆéš¾
- CPU åŠ¨æ€åŠŸè€—
- ç³»ç»Ÿä¸­çš„å…¶ä»–è¿›ç¨‹
- è¶…çº¿ç¨‹
- NUMA
- â€¦â€¦

[ Benchmarking crimes
](https://www.cse.unsw.edu.au/~gernot/benchmarking-crimes.html)

>
é™¤äº†æœ‰é”çš„åˆ‡å‡ºå»è¿™ä¸ªåŸå› ä¹‹å¤–ï¼Œè¿˜å› ä¸ºæœ‰ç¼“å­˜ï¼Œåˆ‡æ¢å¤„ç†å™¨æ‰§è¡Œçš„æ—¶å€™ï¼Œè¦ä¿è¯å½“å‰å¤„ç†å™¨çš„sumå€¼æ˜¯æ­£ç¡®çš„ï¼Œè¦ä»ä¸Šä¸€ä¸ªå¤„ç†å™¨æŠŠsumæ‹‰è¿‡æ¥ï¼Œsumè¿™ä¸ªå˜é‡åœ¨å¤„ç†å™¨çš„ç¼“å­˜ä¹‹é—´æ¥å›ä¼ é€,
å¯¼è‡´æ•ˆç‡é™ä½ã€‚

=== è‡ªæ—‹é”çš„ä½¿ç”¨åœºæ™¯

1. ä¸´ç•ŒåŒºå‡ ä¹ä¸ â€œæ‹¥å µâ€(æ‰€æœ‰çº¿ç¨‹éƒ½è¦ä¸€æŠŠé”ï¼Œå°±ä¼šæ‹¥å µ)
2. æŒæœ‰è‡ªæ—‹é”æ—¶ç¦æ­¢æ‰§è¡Œæµåˆ‡æ¢

ä½¿ç”¨åœºæ™¯ï¼šæ“ä½œç³»ç»Ÿå†…æ ¸çš„å¹¶å‘æ•°æ®ç»“æ„ (çŸ­ä¸´ç•ŒåŒº)

- æ“ä½œç³»ç»Ÿå¯ä»¥å…³é—­ä¸­æ–­å’ŒæŠ¢å 
  - ä¿è¯é”çš„æŒæœ‰è€…åœ¨å¾ˆçŸ­çš„æ—¶é—´å†…å¯ä»¥é‡Šæ”¾é”
- (å¦‚æœæ˜¯è™šæ‹Ÿæœºå‘¢...ğŸ˜‚)
  - PAUSE æŒ‡ä»¤ä¼šè§¦å‘ VM Exit
- ä½†ä¾æ—§å¾ˆéš¾åšå¥½
  - [ An analysis of Linux scalability to many cores (OSDI'10)
    ](https://www.usenix.org/conference/osdi10/analysis-linux-scalability-many-cores)

=== å®ç°çº¿ç¨‹ + é•¿ä¸´ç•ŒåŒºçš„äº’æ–¥

#tip("Tip")[
ä½œä¸šé‚£ä¹ˆå¤šï¼Œä¸å…¶å¹²ç­‰ Online Judge å‘å¸ƒï¼Œä¸å¦‚æŠŠè‡ªå·± (CPU) è®©ç»™å…¶ä»–ä½œä¸š (çº¿ç¨‹) æ‰§è¡Œï¼Ÿ
]

åœ¨å¾—ä¸åˆ°é”çš„æ—¶å€™ï¼Œä¸æµªè´¹CPUï¼Œè®©ç»™åˆ«çš„çº¿ç¨‹æ‰§è¡Œã€‚ä½†æ˜¯â€œè®©â€ ä¸æ˜¯ C
è¯­è¨€ä»£ç å¯ä»¥åšåˆ°çš„ (C ä»£ç åªèƒ½æ‰§è¡ŒæŒ‡ä»¤)

- ä½†æœ‰ä¸€ç§ç‰¹æ®Šçš„æŒ‡ä»¤ï¼šsyscall
- æŠŠé”çš„å®ç°æ”¾åˆ°æ“ä½œç³»ç»Ÿé‡Œå°±å¥½å•¦
  - `syscall(SYSCALL_lock, &lk);`
    - è¯•å›¾è·å¾— lkï¼Œä½†å¦‚æœå¤±è´¥ï¼Œå°±åˆ‡æ¢åˆ°å…¶ä»–çº¿ç¨‹
  - `syscall(SYSCALL_unlock, &lk);`
    - é‡Šæ”¾ lkï¼Œå¦‚æœæœ‰ç­‰å¾…é”çš„çº¿ç¨‹å°±å”¤é†’

æ“ä½œç³»ç»Ÿ = æ›´è¡£å®¤ç®¡ç†å‘˜

- å…ˆåˆ°çš„äºº (çº¿ç¨‹)
  - æˆåŠŸè·å¾—æ‰‹ç¯ï¼Œè¿›å…¥æ¸¸æ³³é¦†
  - \*lk = ğŸ”’ï¼Œç³»ç»Ÿè°ƒç”¨ç›´æ¥è¿”å›
- ååˆ°çš„äºº (çº¿ç¨‹)
  - ä¸èƒ½è¿›å…¥æ¸¸æ³³é¦†ï¼Œæ’é˜Ÿç­‰å¾…
  - çº¿ç¨‹æ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œæ‰§è¡Œçº¿ç¨‹åˆ‡æ¢ (yield)
- æ´—å®Œæ¾¡å‡ºæ¥çš„äºº (çº¿ç¨‹)
  - äº¤è¿˜æ‰‹ç¯ç»™ç®¡ç†å‘˜ï¼›ç®¡ç†å‘˜æŠŠæ‰‹ç¯å†äº¤ç»™æ’é˜Ÿçš„äºº
  - å¦‚æœç­‰å¾…é˜Ÿåˆ—ä¸ç©ºï¼Œä»ç­‰å¾…é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªçº¿ç¨‹å…è®¸æ‰§è¡Œ
  - å¦‚æœç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºï¼Œ\*lk = âœ…
- ç®¡ç†å‘˜ (OS) ä½¿ç”¨è‡ªæ—‹é”ç¡®ä¿è‡ªå·±å¤„ç†æ‰‹ç¯çš„è¿‡ç¨‹æ˜¯åŸå­çš„

=== å…³äºäº’æ–¥çš„ä¸€äº›åˆ†æ

è‡ªæ—‹é” (çº¿ç¨‹ç›´æ¥å…±äº« locked)

- æ›´å¿«çš„ fast path
  - xchg æˆåŠŸ â†’ ç«‹å³è¿›å…¥ä¸´ç•ŒåŒºï¼Œå¼€é”€å¾ˆå°
- æ›´æ…¢çš„ slow path
  - xchg å¤±è´¥ â†’ æµªè´¹ CPU è‡ªæ—‹ç­‰å¾…

äº’æ–¥é” (é€šè¿‡ç³»ç»Ÿè°ƒç”¨è®¿é—® locked)

- æ›´ç»æµçš„ slow path
  - ä¸Šé”å¤±è´¥çº¿ç¨‹ä¸å†å ç”¨ CPU
- æ›´æ…¢çš„ fast path(è¦è¿›kernelæºœä¸€åœˆ, è¿˜è¦åœ¨å†…æ ¸ä¸Šä¸€æŠŠé”)
  - å³ä¾¿ä¸Šé”æˆåŠŸä¹Ÿéœ€è¦è¿›å‡ºå†…æ ¸ (syscall)

=== Futex: Fast Userspace muTexes

#tip("Tip")[
å°å­©å­æ‰åšé€‰æ‹©ï¼Œ oså…¨éƒ½è¦ï¼
]

- fast path: ä¸€æ¡åŸå­æŒ‡ä»¤ï¼Œ ä¸Šé”æˆåŠŸç«‹å³è¿”å›ã€‚
- slow path: ä¸Šé”å¤±è´¥ï¼Œæ‰§è¡Œsystem callç¡çœ 
  - æ€§èƒ½ä¼˜åŒ–æœ€å¸¸è§çš„æŠ€å·§
    - çœ‹average(frequent) caseè€Œä¸æ˜¯worst case

POSIX çº¿ç¨‹åº“ä¸­çš„äº’æ–¥é”ï¼ˆ`pthread_mutex`
- è§‚å¯Ÿçº¿ç¨‹åº“ä¸­çš„lock/unlockè¡Œä¸º
  1. Mutexæ²¡æœ‰äº‰æŠ¢çš„æƒ…å†µ
  2. Mutexæœ‰äº‰æŠ¢çš„æƒ…å†µ

